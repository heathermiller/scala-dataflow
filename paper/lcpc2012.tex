
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{lineno}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage{url}
\urldef{\mails}\path|{firstname.lastname}@epfl.ch|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\makeatletter
\newcommand{\customlabel}[2]{%
\protected@write \@auxout {}{\string \newlabel {#1}{{#2}{}}}}
\makeatother

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{FlowPools: Lock-Free Deterministic Concurrent Data-Flow Queues}

% a short form should be given in case it is too long for the running head
\titlerunning{FlowPools: Lock-Free Deterministic Concurrent Data-Flow Queues}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Authors}
%
% \author{Alfred Hofmann%
% \thanks{Please note that the LNCS Editorial assumes that all authors have used
% the western naming convention, with given names preceding surnames. This determines
% the structure of the names in the running heads and the author index.}%
% \and Ursula Barth\and Ingrid Haas\and Frank Holzwarth\and\\
% Anna Kramer\and Leonie Kunz\and Christine Rei\ss\and\\
% Nicole Sator\and Erika Siebert-Cole\and Peter Stra\ss er}

\authorrunning{FlowPools: Lock-Free Deterministic Concurrent Data-Flow Queues}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{EPFL, Switzerland\\
\mails\\
\url{http://lamp.epfl.ch}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

% \toctitle{Lecture Notes in Computer Science}
% \tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
Implementing correct and deterministic parallel programs is hard (additional motivation sentence after this). We present the design and implementation of a fundamental data structure for deterministic parallel data-flow computation. Aditionally, we provide a proof of correctness, showing that the implementation is linearizable, lock-free, and deterministic. Finally, we provide microbenchmarks which compare our \emph{flow pools} against corresponding operations on other popular concurrent data structures, in addition to performance benchmarks on a real \emph{XYZ} application using real data. (Keep abstract between 70 and 150 words).
\keywords{data-flow, concurrent data-structure, determinism}
\end{abstract}


\section{Introduction}


\subsection{Motivation}

- we want a deterministic model
- we do not block in the programming model (i.e. there are no
operations which cause blocking until a value becomes available)
- we want a non-blocking data-structure (i.e. the operations on the
data-structures should themselves be non-blocking)
- programs run indefinitely => we need to GC parts of the
data structure we no longer need
- we want to reduce heap allocation and inline the datastructure as
much as possible => lower memory consumption, better cache behaviour
and fewer GC cycles


Obligatory multicore motivation paragraph.

Lock-free is better, and why.

Introduction and motivation for data-flow programming model.

\section{Model of Computation}
Producer-consumer parallelism. Description and image of queue/stream of values, producer, and multiple consumers. 

\section{Programming Model}
The FlowPool suite supports the following operations:
\begin{itemize}
\item \texttt{Builder.<<(x: T): Builder}\\
  Inserts an element into the underlying FlowPool.
\item \texttt{Builder.seal(n: Int): Unit}\\
  Seals the underlying FlowPool at \texttt{n} elements. The need for
  the size argument is explained below. A sealed FlowPool may only
  contain \texttt{n} elements. This allows for callback cleanup and
  termination.
\item \texttt{FlowPool.doForAll(f: T => Unit): Future[Int]}\\
  Instructs
  the FlowPool to execute the closure \texttt{f} exactly once for each
  element inserted into the FlowPool (asynchronously). The returned
  future contains the number of elements in the FlowPool and completes
  once \texttt{f} has been executed for all elements.
\item \texttt{FlowPool.mappedFold[U, V <: U](acc: V)(cmb: (U,V) =>
    V)(map: T => U): Future[(Int, V)]}
  Reduces the FlowPool to a single value of type V, by first mapping
  each element to an internal representation using \texttt{map} and
  then aggregating using \texttt{cmb}. No guarantee is given about
  synchronization or order. Returns a future containing a tuple with
  number of elements in the FlowPool and the aggregated value.
\item \texttt{FlowPool.builder}\\
  Returns a builder for this FlowPool.
\item \texttt{Future.map[U](f: T => U)}\\
  Maps this future to another
  future executing the function \texttt{f} exactly once when the first
  future completes.
\item \texttt{future[T](f: () => T): Future[T]}\\
  Asynchronously dispatch execution of \texttt{f} an return a future
  with its result.
\end{itemize}

\paragraph{Determinism of \texttt{seal}} We will show that the final
size of the FlowPool is required as an argument to the seal method in
order to satisfy the determinism property of the FlowPool. Look at the
following program:

\begin{verbatim}
val p = new FlowPool[Int]()
val b = p.builder

future {
  for (i <- 1 to 10) { b << i }
  b.seal
}

future { for (i <- 1 to 10) { b << i } }
\end{verbatim}

Depending on which for-loop completes first, this program completes
successfully or yields an error. A similar program with
\verb+b.seal(20)+ will always succeed.

\paragraph{Generators} In the following we'll present a couple of
generators for FlowPools based on common generators in the Scala
standard library.

\begin{verbatim}
def iterate[T](start: T, len: Int)(f: (T) => T) = {
  val p = new FlowPool[T]
  val b = p.builder
  future {
    var e = start
    for (i <- 1 to len) { b << e; e = f(e) }
    b.seal(len)
  }; p
}
\end{verbatim}

\begin{verbatim}
def tabulate[T](n: Int)(f: (Int) => T) = {
  val p = new FlowPool[T]
  val b = p.builder
  future {
    for (i <- 0 to (n-1)) {
      b << f(i)
    }
    b.seal(n)
  }; p
}
\end{verbatim}

\begin{verbatim}
def fill[T](n: Int)(elem: => T) = {
  val p = new FlowPool[T]
  val b = p.builder
  future {
    for (i <- 1 to n) { b << elem }
    b.seal(n)
  }; p
}
\end{verbatim}

\paragraph{Monadic Operations} In the following we'll present some
monadic operations on top of the basic FlowPool operations. This will
also show some use-cases of the futures as result type of
\verb+doForAll+.

\begin{verbatim}
def map[S](f: T => S) = {
  val fp = new FlowPool[S]
  val b  = fp.builder
  doForAll { x =>
    b << f(x)
  } map { b.seal _ }
  fp
}
\end{verbatim}

\begin{verbatim}
def filter(f: T => Boolean) = {
  val fp = new FlowPool[T]
  val b  = fp.builder

  mappedFold(0)(_ + _) { x =>
    if (f(x)) { b << x; 1 } else 0
  } map { case (c,fc) => b.seal(fc) }

  fp
}
\end{verbatim}

\begin{verbatim}
def flatMap[S](f: T => FlowPool[S]) = {
  val fp = new FlowPool[S]
  val b  = fp.builder

  mappedFold(future(0))(_ <+> _) { x =>
    f(x).doForAll(b << _)
  } map { case (c,cfut) => cfut.map(b.seal _) }

  fp
}
\end{verbatim}
where \verb|<+>| is the future of the sum of two \verb+Future[Int]+.

\section{Implementation}

\begin{alltt}
{\scriptsize
type Elem

type Block \{
  array: Array
  next: Block
  index: Int
  blockindex: Int
\}

type FlowPool \{
  start: Block
  current: Block
\}

type Terminal \{
  sealed: Int
  callbacks: List[Elem => Unit]
\}

BLOCKSIZE = 256
LASTELEMPOS = BLOCKSIZE - 2
NOTSEALED = -1
}
\end{alltt}


\begin{alltt}
{\scriptsize
{\internallinenumbers{def append(elem: Elem)
  b = READ(current) {\customlabel{read_block}{\LineNumber}}
  idx = READ(b.index) {\customlabel{read_index}{\LineNumber}}
  nextobj = READ(b.array(idx + 1)) {\customlabel{read_next}{\LineNumber}}
  curobj = READ(b.array(idx)) {\customlabel{read_current}{\LineNumber}}
  if (check(b, idx, curobj, nextobj)) \{
    if (CAS(b.array(idx + 1), nextobj, curobj)) \{ {\customlabel{cas_propagate}{\LineNumber}}
      if (CAS(b.array(idx), curobj, elem)) \{ {\customlabel{cas_append}{\LineNumber}}
        WRITE(b.index, idx + 1) {\customlabel{write_append}{\LineNumber}}
        invokeCallbacks(elem, curobj)
      \} else append(elem)
    \} else append(elem)
  \} else \{
    advance()
    append(elem)
  \}

def check(b: Block, idx: Int, curobj: Object, nextobj: Object)
  // The check on the index is done implicitly in the real code
  if (idx > LASTELEMPOS) return false
  else curobj match \{
    elem: Elem =>
      return false
    term: Terminal =>
      if (term.sealed == NOTSEALED) return true
      else \{
        if (totalElems(b, idx) < term.sealed) return true
        else error("sealed")
      \}
    null =>
      error("unreachable")
  \}

def advance()
  b = READ(current)
  idx = READ(b.index)
  if (idx > LASTELEMPOS) expand(b, b.array(idx))
  else \{
    obj = READ(b.array(idx))
    if (obj is Elem) WRITE(b.index, idx + 1) {\customlabel{write_advance}{\LineNumber}}
  \}

def expand(b: Block, t: Terminal)
  nb = READ(b.next)
  if (nb is null) \{
    nb = createBlock(b.blockindex + 1)
    nb.array(0) = t
    if (CAS(b.next, null, nb)) {\customlabel{cas_expand}{\LineNumber}}
      expand(b, t)
  \} else \{
    CAS(current, b, nb) {\customlabel{cas_block}{\LineNumber}}
  \}

def totalElems(b: Block, idx: Int)
  return b.blockindex * (BLOCKSIZE - 1) + idx

def invokeCallbacks(elem: Elem, term: Terminal)
  for (f <- term.callbacks) future \{
    f(elem)
  \}

def seal(size: Int)
  b = READ(current)
  idx = READ(b.index)
  if (idx <= LASTELEMPOS) \{
    curobj = READ(b.array(idx)) {\customlabel{read_seal}{\LineNumber}}
    curobj match \{
      term: Terminal =>
        tryWriteSeal(term, b, idx, size)
      elem: Elem =>
        WRITE(b.index, idx + 1) {\customlabel{write_seal}{\LineNumber}}
        seal(size)
      null =>
        error("unreachable")
    \}
  \} else \{
    expand(b, b.array(idx))
    seal(size)
  \}

def tryWriteSeal(term: Terminal, b: Block, idx: Int, size: Int)
  val total = totalElems(b, idx)
  if (total > size) error("too many elements")
  if (term.sealed == NOTSEALED) \{
    nterm = new Terminal \{
      sealed = size
      callbacks = term.callbacks
    \}
    CAS(b.array(idx), term, nterm) {\customlabel{cas_seal}{\LineNumber}}
  \} else if (term.sealed != size) \{
    error("already sealed with different size")
  \}

def doForAll(f: Elem => Unit)
  future \{
    asyncDoForAll(f, start, 0)
  \}

def asyncDoForAll(f: Elem => Unit, b: Block, idx: Int)
  if (idx <= LASTELEMPOS) \{
    obj = READ(b.array(idx)) {\customlabel{read_callback}{\LineNumber}}
    obj match \{
      term: Terminal =>
        nterm = new Terminal \{
          sealed = term.sealed
          callbacks = f :: term.callbacks
        \}
        if (!CAS(b.array(idx), term, nterm)) asyncDoForAll(f, b, idx) {\customlabel{cas_callback}{\LineNumber}}
      elem: Elem =>
        f(elem) {\customlabel{call_callback}{\LineNumber}}
        asyncDoForAll(f, b, idx + 1)
      null =>
        error("unreachable")
    \}
  \} else \{
    // In the real code we take a shortcut when preparing the new block
    expand(b, b.array(idx))
    asyncDoForAll(f, b.next, 0)
  \}

}}}
\end{alltt}

We now describe the FlowPool and its basic operations.
In doing so, we avoid the details not relevant to the algorithm
(specifically, the builder abstraction) and
focus on a high-level description of a non-blocking data structure.
One straightforward way to implement a growing pool is to use a linked
list of nodes that wrap elements.
As we are concerned about the memory footprint and cache-locality, we
store the elements into arrays instead, which we call blocks.
Whenever a block becomes full, a new block is allocated and the
previous block is made to point to the \verb=next= block.
This way, most writes amount to a simple array-write, while allocation
occurs only occasionally.



\section{Proofs}
\subsection{Abstract Pool Semantics}
Alex
\subsection{Linearizability}
Alex
\subsection{Lock-Freedom}

\subsection{Determinism}

\section{Experimental Results}

\section{Related Work}
Things to probably cite: Oz, gpars, Java CLQ, our futures writeup.

Things we should probably have a look at: Microsoft TPL, Dataflow
Java, FlumeJava...

Forcing a bib, \cite{bowman:reasoning}, \cite{braams:babel}, \cite{clark:pct}, \cite{herlihy:methodology}, \cite{Lamport:LaTeX}, \cite{salas:calculus}
\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{bib}


\setcounter{lemma}{0}
\setcounter{theorem}{0}
\setcounter{corollary}{0}
\setcounter{definition}{0}


\begin{definition}[FlowPool]
The \textbf{FlowPool} is defined as a pair of references $start$ and
$current$.

The \textbf{FlowPool state} is defined as a pair of the directed graph of
objects transitively reachable from the reference $start$ and the set
of scheduled callback invocations called $futures$.

A \textbf{scheduled callback invocation} is a pair $(f, e)$ of a function
$f \in Elem => Unit$ and an element $e \in Elem$.
The programming construct that adds such a pair to the set of
$futures$ is \verb=future { f(e) }=.

We define the following relations:

\begin{equation*}
following(b: Block) = 
\begin{cases}
\emptyset & \text{if b.next = null,}
\\
b.next \cup following(b.next) & \text{otherwise}
\end{cases}
\end{equation*}

\begin{equation*}
reachable(b: Block) = \{ b \} \cup following(b)
\end{equation*}

\begin{equation*}
last(b: Block) = b' : b' \in reachable(b) \wedge b'.next = null
\end{equation*}

\begin{equation*}
size(b: Block) = | \{ x : x \in b.array \wedge x \in Elem \} |
\end{equation*}

We say that the FlowPool \textbf{has an element} $e$ at some time
$t_0$ if and only if the relation $hasElem(start, e)$ holds.

\begin{equation*}
hasElem(start, e) \Leftrightarrow \exists b \in reachable(start), e
\in b.array
\end{equation*}

We say that the FlowPool \textbf{has a callback} $f$ at some time
$t_0$ if and only if the relation $hasCallback(start, f)$ holds.

\begin{equation*}
hasCallback(start, f) \Leftrightarrow \forall b = last(start), b.array
= x^P \cdot t \cdot y^N, x \in Elem, t = Terminal(seal, callbacks), f
\in callbacks
\end{equation*}

We say that a callback $f$ in a FlowPool \textbf{will be called} for
the element $e$ at some time $t_0$ if and only if the relation
$willBeCalled(start, e, f)$ holds.

\begin{equation*}
willBeCalled(start, e, f) \Leftrightarrow \exists t_0, \forall t >
t_0, (f, e) \in futures
\end{equation*}

We say that the FlowPool is \textbf{sealed} at the size $s$ at some
$t_0$ if and only if the relation $sealedAt(start, s)$ holds.

\begin{equation*}
sealedAt(start, s) \Leftrightarrow \forall b = last(start), b.array
= x^P \cdot t \cdot y^N, x \in Elem, t = Terminal(\{s\}, callbacks)
\end{equation*}

\textbf{FlowPool operations} are \verb=append=, \verb=foreach= and \verb=seal=, and are defined by pseudocodes in figures ...
\end{definition}


\begin{definition}[Invariants]
We define the following invariants for the \textbf{FlowPool}:
\begin{description}
\item[INV1] $start = b: Block, b \neq null, current \in reachable(start)$
\item[INV2] $\forall b \in reachable(start), b \not \in following(b)$
\item[INV3] $\forall b \in reachable(start), b \neq last(start) \Rightarrow size(b) = LASTELEMPOS \wedge b.array(BLOCKSIZE - 1) \in Terminal$
\item[INV4]
$\forall b = last(start), b.array = p \cdot c \cdot n$, where:

$p = X^P, c = c_1 \cdot c_2, n = null^N$

$x \in Elem, c_1 \in Terminal, c_2 \in \{null\} \cup Terminal$

$P + N + 2 = BLOCKSIZE$
\item[INV5] $\forall b \in reachable(start), b.index > 0 \Rightarrow b.array(b.index - 1) \in Elem$
\end{description}
\end{definition}


\begin{definition}[Validity]
A FlowPool state $\mathbb{S}$ is \textbf{valid} if and only if the invariants [INV1-5] hold for that state.
\end{definition}


\begin{definition}[Abstract pool]
An \textbf{abstract pool} $\mathbb{P}$ is a function from time $t$ to a tuple of sets $(elems, callbacks, seal)$ such that:
\begin{description}
\item $seal \in \{ \emptyset, \{ w \} \}, w \in \mathbb{N}$
\item $callbacks \subset \{ (f: Elem => Unit, called) \}$
\item $called \subseteq elems \subseteq Elem$
\end{description}
We say that an abstract pool $\mathbb{P}$ \textbf{is in state} $(elems, callbacks, seal)$ at time $t$ if and only if $\mathbb{P}(t) = (elems, callbacks, seal)$.
\end{definition}


\begin{definition}[Abstract pool operations]
We say that an \textbf{abstract pool operation} $op$ applied to an abstract pool $P_0 = (elems_0, callbacks_0, seal_0)$ 
at some time $t$ \textbf{changes} the state of the abstract pool to $P = (elems, callbacks, seal)$ 
if $\exists t_0, \forall \tau, t_0 < \tau < t, \mathbb{P}(\tau) = P_0$ and $\mathbb{P}(t) = P$.

Abstract pool operation $foreach(f)$ changes the state at $t_0$ from $(elems, callbacks, seal)$ 
to $(elems, (f, \emptyset) \cup callbacks, seal)$. Furthermore:

$\exists t_1 > t_0, \forall t_2 > t_1, \mathbb{P}(t_2) = (elems_2,
callbacks_2, seal_2) \wedge \forall (f, called_2) \in callbacks_2,
elems \subseteq called_2 \subseteq elems_2$

Abstract pool operation $append(e)$ changes the state at $t_0$ from
$(elems, callbacks, seal)$ to $(\{e\} \cup elems, callbacks, seal)$. Furthermore:

$\exists t_1 > t_0, \forall t_2 > t_1, \mathbb{P}(t_2) = (elems_2,
callbacks_2, seal_2) \wedge \forall (f, called_2) \in callbacks_2,
(f, called) \in callbacks \Rightarrow elem \in called_2$

Abstract pool operation $seal(s)$ changes the state at $t_0$ from
$(elems, callbacks, seal)$ to $(elems, callbacks, \{s\})$, assuming
that $seal \in \{ \emptyset, \{s\} \}$.

\end{definition}


\begin{definition}[Consistency]
A FlowPool state $\mathbb{S}$ is \textbf{consistent} with an abstract pool 
$\mathbb{P} = (elems, callbacks, seal)$ at $t_0$ if and only if $\mathbb{S}$ 
is a valid state and:
\begin{description}
\item $\forall e \in Elem, hasElem(start, e) \Leftrightarrow e \in elems$
\item $\forall f \in Elem => Unit, \forall e \in Elem, willBeCalled(start, e, f) \Leftrightarrow \exists t_1 \geq t_0, \mathbb{P}(t_1) = (elems_1, (f, called_1) \cup callbacks_1, seal_1), elems \subseteq called_1$
\item $\forall s \in \mathbb{N}, sealedAt(start, s) \Leftrightarrow s \in seal$
\end{description}

A FlowPool operation $op$ completing at some time $t_0$ is consistent with an abstract pool operation $op'$ if 
and only if $op$ changes the state of the FlowPool from $\mathbb{S}_1$ to $\mathbb{S}_2$, where $\mathbb{S}_1$ 
and $\mathbb{S}_2$ are consistent with the abstract pool states $\mathbb{A}_1$ and $\mathbb{A}_2$, respectively, 
and $op'$ changes the state of the abstract pool from $\mathbb{A}_1$ to $\mathbb{A}_2$.
\end{definition}


\begin{proposition}
Every valid state is consistent with some abstract pool.
\end{proposition}


\begin{theorem}[Safety]
FlowPool operation \verb=create= creates a new FlowPool consistent with the abstract pool 
$\mathbb{P} = (\emptyset, \emptyset, \emptyset)$. FlowPool operations \verb=foreach=, \verb=append= 
and \verb=seal= are consistent with the abstract pool semantics.
\end{theorem}


\begin{lemma}[End of life]\label{lemma-end-of-life}
For all blocks $b \in reachable(start)$, if value $v \in Elem$ is
written to $b.array$ at some position $idx$ at some time $t_0$, then
$\forall t > t_0, b.array(idx) = v$.
\end{lemma}

\begin{proof}
The CAS in line \ref{cas_append} is the only CAS which writes an
element.
No other CAS has a value of type $Elem$ as the expected value.
This means that once the CAS in line \ref{cas_append} writes a value
of type $Elem$, no other write can change it.
\end{proof}


\begin{corollary}\label{cor-end-of-life}
The end of life lemma implies that if all the values in $b.array$ are
of type $Elem$ at $t_0$, then $\forall t > t_0$ there is no write to $b.array$.
\end{corollary}


\begin{lemma}[Valid hint]\label{lemma-valid-hint}
For all blocks $b \in reachable(start)$, if $b.index > 0$ at some time $t_0$, then
$b.array(b.index - 1) \in Elem$ at time $t_0$.
\end{lemma}

\begin{proof}
Observe every write to $b.index$ -- they are all unconditional.
However, at every such write occurring at some time $t_1$ that writes
some value $idx$ we know that some previous value at $b.array$ entry $idx - 1$
at some time $t_0 < t_1$ was of type $Elem$.
Hence, from lemma \ref{lemma-end-of-life} it follows that
$\forall t \geq t_1, b.array(idx - 1) \in Elem$.
\end{proof}


\begin{corollary}[Compactness]\label{cor-compactness}
For all blocks $b \in reachable(start)$, if for some $idx$
$b.array(idx) \in Elem$ at time $t_0$ then $b.array(idx - 1) \in Elem$
at time $t_0$. This follows
directly from the lemmas \ref{lemma-end-of-life} and
\ref{lemma-valid-hint}, and the fact that the CAS in line
\ref{cas_append} only writes to array entries $idx$ for which it
previously read the value from $b.index$.
\end{corollary}


\begin{definition}[Transition]
If for a function $f(t)$ there exist times $t_0$ and $t_1$ such that
$\forall t, t_0 < t < t_1, f(t) = v_0$ and $f(t_1) = v_1$, then we say
that the function $f$ goes through a \textbf{transition} at $t_1$. We denote this as:

$f: v_0 \stackrel{t_1}{\rightarrow} v_1$

Or, if we don't care about the exact time $t_1$, simply as:

$f: v_0 \rightarrow v_1$
\end{definition}


\begin{definition}[Monotonicity]
A function of time $f(t)$ is said to be \textbf{monotonic}, if every value in its string of transitions occurs only once.
\end{definition}


\begin{lemma}[Freshness]\label{lemma-freshness}
For all blocks $b \in reachable(start)$, and for all $x \in b.array$,
function $x$ is monotonic.
\end{lemma}

\begin{proof}
CAS instruction in line \ref{cas_append} writes a value of type
$Elem$. No CAS instruction has a value of type $Elem$ as the expected value.

Trivial analysis of CAS instructions in lines \ref{cas_seal} and
\ref{cas_callback}, shows that their expected values are of type
$Terminal$. Their new values are always freshly allocated.

The more difficult part is to show that CAS instruction in line
\ref{cas_propagate} respects the statement of the lemma.

Since the CAS instructions in lines \ref{cas_seal} and
\ref{cas_callback} are preceeded by a read of $idx = b.index$,
from lemma \ref{lemma-valid-hint} it follows that $b.array(idx - 1)$ 
contains a value of type $Elem$.
These are also the only CAS instructions which replace a $Terminal$
value with another $Terminal$ value. The new value is always unique, as
shown above.

So the only potential CAS to write a non-fresh value to $idx + 1$ is the CAS
in line \ref{cas_propagate}.

A successful CAS in line \ref{cas_propagate} overwrites a value $cb_0$ at $idx + 1$
read in line \ref{read_next} at $t_0$ with a new value $cb_2$ at time $t_2$. Value $cb_2$ was
read in line \ref{read_current} at $t_1$ from the entry $idx$. The
string of transitions of values at $idx$ is composed of unique values
at least since $t_1$ (by lemma \ref{lemma-end-of-life}), since there is
a value of type $Elem$ at the index $idx - 1$.

The conclusion above ensures that the values read in line \ref{read_current}
to be subsequently used as new values for the CAS in line \ref{cas_propagate}
form a monotonic function $f(t) = b.array(idx) \text{ at } t$.

Now assume that a thread T1 successfully overwrites $cb_0$
via CAS in line \ref{cas_propagate} at $idx + 1$ at time $t_2$ 
to a value $cb_2$ read from $idx$ at $t_1$, and that another thread T2 
is the \textbf{first} thread (since the FlowPool was created) to subsequently successfully
complete the CAS in line \ref{cas_propagate} at $idx + 1$ at time
$t_{prev2} > t_2$ with some value $cb_{prev2}$ which was at $idx + 1$ at some time
$t < t_0$.

That would mean that $b.array(idx + 1)$ does not change during $\langle t_0, t_2 \rangle$,
since T2 was the first thread the write a non-fresh value to $idx + 1$, and any
other write would cause the CAS in line \ref{cas_propagate} by T1 to fail.
%That means that $t_0 > t_{prev0}$, otherwise the CAS in line \ref{cas_propagate}
%by T2 would have failed.

Also, that would mean that the thread T2 read the value
$cb_{prev2}$ in line \ref{read_current} at some time $t_{prev1} < t_1$
and successfully completed the CAS at time $t_{prev2} > t_2$. If the
CAS was successful, then the read in line \ref{read_next} by T2
occured at $t_{prev0} < t_{prev1} < t_1$. Since we assumed that T2 is the
first thread to write a value $cb_{prev2}$ to $idx + 1$ at time $t_{prev2}$
which was previously in $idx + 1$ at some time $t < t_0$, then the CAS
in line \ref{cas_propagate} at time $t_{prev2}$ could not have succeeded,
since its expected value is $cb_{prev0}$ read at some time $t_{prev0}$, and
we know that the value at $idx + 1$ was changed at least once in $\langle t_{prev0}, t_{prev2} \rangle$
because of the write of a fresh value by thread T1 at $t_2 \in \langle t_{prev0}, t_{prev2} \rangle$.
This value is known to be fresh because $b.array(idx)$ is a monotonic
function at least since $t_{prev1}$, and the read of the new value
written by T1 occurred at $t_1 > t_{prev1}$.
We also know that there is no other thread T3 to write the value
 $cb_{prev0}$ during $\langle t_{prev0}, t_{prev2} \rangle$
back to $idx + 1$, since we assumed that T2 is the first to write
a non-fresh value at that position.

Hence, a contradiction shows that there is no thread T2 which is the \textbf{first}
to write a non-fresh value via CAS in line \ref{cas_propagate} at $idx + 1$
for any $idx$, so there is no thread that writes a non-fresh value at all.
\end{proof}


\begin{lemma}[Lifecycle]\label{lemma-lifecycle}
For all blocks $b \in reachable(start)$, and for all $x \in b.array$, function $x$ goes through and only through the prefix of the following transitions:

$null \rightarrow cb_1 \rightarrow \dots \rightarrow cb_n \rightarrow elem$, where:

$cb_i \in Terminal, i \neq j \Rightarrow cb_i \neq cb_j, elem \in Elem$
\end{lemma}

\begin{proof}
First of all, it is obvious from the code that each block that becomes
an element of $reachable(start)$ at some time $t_0$ has the value of
all $x \in b.array$ set to $null$.

Next, we inspect all the CAS instructions that operate on entries of
$b.array$.

The CAS in line \ref{cas_append} has a value $curobj \in Terminal$ as
an expected value and writes an $elem \in Elem$.
This means that the only transition that this CAS
can cause is of type $cb_i \in Terminal \rightarrow elem \in Elem$.

We will now prove that the CAS in line \ref{cas_propagate} at time $t_2$ is successful if and
only if the entry at $idx + 1$ is $null$ or $nextobj \in
Terminal$.
We know that the entry at $idx + 1$ does not change $\forall t, t_0 < t < t_2$,
where $t_0$ is the read in line \ref{read_next},
because of lemma \ref{lemma-freshness} and the fact that CAS in line \ref{cas_propagate} is assumed to be successful.
We know that during the read in line \ref{read_current} at time $t_1$,
such that $t_0 < t_1 < t_2$, the entry at $idx$ was $curobj \in
Terminal$, by trivial analysis of the \verb=check= procedure.
It follows from corollary \ref{cor-compactness} that the array entry $idx
+ 1$ is not of type $Elem$ at time $t_1$, otherwise array entry $idx$
would have to be of type $Elem$.
Finally, we know that the entry at $idx + 1$ has the same value during
the interval $\langle t_1, t_2 \rangle$, so its value is not $Elem$ at $t_2$.

The above reasoning shows that the CAS in line \ref{cas_propagate}
always overwrites a one value of type $Terminal$ (or $null$) with
another value of type $Terminal$.
We have shown in lemma \ref{lemma-freshness} that it never
overwrites the value $cb_0$ with a value $cb_2$ that was at
$b.array(idx)$ at an earlier time.

Finally, note that the statement for CAS instructions in lines \ref{cas_seal} and
\ref{cas_callback} also follows directly from the proof for lemma \ref{lemma-freshness}.
\end{proof}


\begin{lemma}[Subsequence]\label{lemma-subsequence}
Assume that for some block $b \in reachable(start)$ the transitions of
$b.array(idx)$ are:

\begin{equation*}
b.array(idx): null \rightarrow cb_1 \rightarrow \cdots \rightarrow
cb_n \stackrel{t_0}{\rightarrow} elem: Elem
\end{equation*}

Assume that the transitions of $b.array(idx + 1)$ up to time $t_0$ are:

\begin{equation*}
b.array(idx + 1): null \rightarrow cb_1' \rightarrow \cdots
\rightarrow cb_m'
\end{equation*}

The string of transitions $null \rightarrow cb_1' \rightarrow \cdots
\rightarrow cb_m'$ is a subsequence of $null \rightarrow cb_1
\rightarrow \cdots \rightarrow cb_n$.
\end{lemma}

\begin{proof}
Note that all the values written to $idx + 1$ before $t_0$ by CAS in line \ref{cas_propagate} were
previously read from $idx$ in line \ref{read_current}.
This means that the set of values occurring in $b.array(idx + 1)$
before $t_0$ is a subset of the set of values in $b.array(idx)$.
We have to prove that it is actually a subsequence.

Assume that there exist two values $cb_1$ and $cb_2$ read by threads T1 and T2
in line \ref{read_current} at times $t_1$ and $t_2 > t_1$, respectively.
Assume that these values are written to $idx + 1$ by threads T1 and T2
in line \ref{cas_propagate} in the opposite order, that is at times
$t_{cas1}$ and $t_{cas2} < t_{cas1}$, respectively.
That would mean that the CAS by thread T1 would have to fail, since its expected
value $cb_0$ has changed between the time it was read in line \ref{read_next} and
the $t_{cas1}$ at least once to a different value, and it could not have been
changed back to $cb_0$ as we know from the lemma
\ref{lemma-freshness}.

Notice that we have actually prooved a stronger result above.
We have also shown that the string of values
written at $idx + 1$ by CAS in line \ref{cas_propagate} successfully is a subsequence
of \textbf{all} the transitions of values at $idx$ (not just until $t_0$).
\end{proof}


\begin{lemma}[Valid writes]\label{lemma-valid}
Given a FlowPool in a valid state, all writes in all operations produce a FlowPool in a valid state.
\end{lemma}

\begin{proof}
A new FlowPool is trivially in a valid state.

Otherwise, assume that the FlowPool is in a valid state
$\mathbb{S}$.
In the rest of the proof, whenever some invariant is trivially
unaffected by a write, we omit mentioning it.
We start by noting that we already prooved the claim
for atomic writes in lines \ref{write_append}, \ref{write_advance} and
\ref{write_seal} (which only affect [INV5]) in lemma
\ref{lemma-valid-hint}.
We proceed by analyzing each atomic CAS instruction.

CAS in line \ref{cas_expand} at time $t_1$ maintains the invariant
[INV1].
This is because its expected value is always
$null$, which ensures that the lifecycle of $b.next$ is $null
\rightarrow b': Block$, meaning that the function $reachable(start)$
returns a monotonically growing set.
So if $current \in reachable(start)$ at $t_0$, then this also holds at
$t_1 > t_0$.
It also maintains [INV2] because the new value $nb$ is always fresh,
so $\forall b, b \not \in following(b)$.
Finally, it maintains [INV3] because it is preceeded with a bounds
check and we know from corollary \ref{cor-compactness} and the
lemma \ref{lemma-end-of-life} that all the values in $b.array(idx),
idx < LASTELEMPOS$ must be of type $Elem$.

CAS in line \ref{cas_block} at time $t_1$ maintains the
invariant [INV1], since the new value for the $current \neq null$ was read from
$b.next$ at $t_0 < t_1$ when the invariant was assumed to hold, and
it is still there a $t_1$, as shown before.

For CAS instructions in lines \ref{cas_append}, \ref{cas_callback} and
\ref{cas_seal} that write to index $idx$ we know from lemma
\ref{lemma-valid-hint} that the value at $idx - 1$ is of type $Elem$.
This immediately shows that CAS instructions in lines
\ref{cas_callback} and \ref{cas_seal} maintain [INV3] and [INV4].

For CAS in line \ref{cas_append} we additionally know that it must
have been preceeded by a successful CAS in line \ref{cas_propagate}
which previously wrote a $Terminal$ value to $idx + 1$. From lemma
\ref{lemma-lifecycle} we know that $idx + 1$ is still $Terminal$ when
the CAS in line \ref{cas_append} occurs, hence [INV4] is kept.

Finally, CAS in line \ref{cas_propagate} succeeds only if the value at
$idx + 1$ is of type $Terminal$, as shown before in lemma
\ref{lemma-lifecycle}.
By the same lemma, the value at $idx$ is either
$Terminal$ or $Elem$ at that point, since $idx - 1$ is known to be
$Elem$ by lemma \ref{lemma-valid-hint}.
This means that [INV4] is kept.
\end{proof}


\begin{lemma}[Housekeeping]\label{lemma-housekeeping}
Given a FlowPool in state $\mathbb{S}$ consistent with some abstract
pool state $\mathbb{A}$, CAS instructions in lines \ref{cas_propagate}, \ref{cas_expand} and
\ref{cas_block} do not change the abstract pool state $\mathbb{A}$.
\end{lemma}

\begin{proof}
Since none of the relations $hasElem$, $hasCallback$, $willBeCalled$ and $sealedAt$
are defined by the value of $current$ CAS in line \ref{cas_block}
does not change them, hence it does not change the abstract pool
state.

No CAS changes the set of scheduled futures, nor is
succeeded by a \verb=future= construct so it does not affect
the $willBeCalled$ relation.

It is easy to see that the CAS in line \ref{cas_expand} does not remove any elements, nor make
any additional elements reachable, since the new block $nb$ which
becomes reachable does not contain any elements at that time.
Hence the $hasElem$ relation is not affected.
It does change the value $last(start)$ to $nb$, but since $nb.array =
t \cdot null^{BLOCKSIZE - 1}$, where $t \in Terminal$ was previously
the last non-null element in $b.array$, it does changes neither the
$sealedAt$ nor the $hasCallback$ relation.

The CAS in line \ref{cas_propagate} does not make some new element reachable,
hence the $hasElem$ relation is preserved.

Note now that this CAS does not change the relations $hasCallback$
and $sealedAt$ as long as there is a value of type $Terminal$ at the
preceeding entry $idx$.
We claim that if the CAS succeeds at $t_2$, then 
either the value at $idx$ is of type $Terminal$ (trivially) or the CAS
did not change the value at $idx + 1$.
In other words, if the value at $idx$ at time $t_2$ is of type $Elem$,
then the write by CAS in line \ref{cas_propagate} does not change
the value at $idx + 1$ at $t_2$.
This was, in fact, already shown in the proof of lemma \ref{lemma-subsequence}.

The argument above proves directly that relations $hasCallback$
and $sealedAt$ are not changed by the CAS in line \ref{cas_propagate}.
\end{proof}


\begin{lemma}[Append correctness]\label{lemma-append}
Given a FlowPool in state $\mathbb{S}$ consistent with some abstract pool state $\mathbb{A}$, 
a successful CAS in line \ref{cas_append} at some time $t_0$ changes the state of the FlowPool 
to $\mathbb{S}_0$ consistent with an abstract pool state $\mathbb{A}_0$, such that:

$\mathbb{A} = (elems, callbacks, seal)$

$\mathbb{A}_0 = (\{elem\} \cup elems, callbacks, seal)$

Furthermore, given a fair scheduler, there exists a time $t_1 > t_0$ at which the FlowPool 
is consistent with an abstract pool in state $\mathbb{A}_1$, such that:

$\mathbb{A}_1 = (elems_1, callbacks_1, seal_1)$, where:

$\forall (f, called_1) \in callbacks_1, (f, called) \in callbacks \Rightarrow elem \in called_1$
\end{lemma}

\begin{proof}
Assume that the CAS in line \ref{cas_append} succeeds at some time
$t_3$, the CAS in line \ref{cas_propagate} succeeds at some time $t_2 <
t_3$, the read in line \ref{read_current} occurs at some time $t_1 <
t_2$ and the read in line \ref{read_current} occurs at some time $t_0
< t_1$.

It is easy to see from the invariants, $check$ procedure and the
corollary \ref{cor-end-of-life} that the CAS in line \ref{cas_append} can only
occur if $b = last(start)$.

We claim that for the block $b \in reachable(start)$ such that $b = last(b)$ the
following holds at $t_2$:

$b.array = elem^N \cdot cb_1 \cdot cb_2 \cdot null^{BLOCKSIZE - N - 2}$

where $cb_1 = cb_2$, since there was no write to $idx$ after $cb_1$, otherwise the
CAS in line \ref{cas_append} at $t_3$ would not have been successful
(by lemma \ref{lemma-freshness}).

Furthermore, $cb_1 = cb_2$ at $t_3$, as shown in the lemma
\ref{lemma-subsequence}. Due to the same lemma, the entries of
$b.array$ stay the same until $t_3$, otherwise the CAS in line
\ref{cas_append} would not have been successful.
After the successful CAS at $t_3$, we have:

$b.array = elem^N \cdot e \cdot cb_1 \cdot null^{BLOCKSIZE - N - 2}$

where $e: Elem$ is the newly appended element -- at $t_3$ the
relation $hasElem(start, e)$ holds, and $sealedAt(start, s)$ and
$hasCallback(start, f)$ did not change between $t_2$ and $t_3$.

It remains to be shown that $willBeCalled(start, e, f)$ holds at $t_3$.
Given a fair scheduler, within a finite number of steps the
future store will contain a request for an asynchronous computation
that invokes $f$ on $e$. The fair scheduler ensures that the future is
scheduled within a finite number of steps.
\end{proof}


\begin{lemma}[Foreach correctness]\label{lemma-foreach}
Given a FlowPool in state $\mathbb{S}$ consistent with some abstract pool state $\mathbb{A}$, 
a successful CAS in line \ref{cas_callback} at some time $t_0$ changes the state of the FlowPool 
to $\mathbb{S}_0$ consistent with an abstract pool state $\mathbb{A}_0$, such that:

$\mathbb{A} = (elems, callbacks, seal)$

$\mathbb{A}_0 = (elems, (f, \emptyset) \cup callbacks, seal)$

Furthermore, given a fair scheduler, there exists a time $t_1 \geq t_0$ at which the FlowPool 
is consistent with an abstract pool in state $\mathbb{A}_1$, such that:

$\mathbb{A}_1 = (elems_1, callbacks_1, seal_1)$, where:

$elems \subseteq elems_1$

$\forall (f, called_1) \in callbacks_1, elems \subseteq called_1$
\end{lemma}

\begin{proof}
From lemma \ref{lemma-freshness} and the assumption that the CAS is
successful we know that the value at $b.array(idx)$ has not changed
between the read in line \ref{read_callbacks} and the CAS in line
\ref{cas_callback}.
From lemma \ref{lemma-valid-hint} we know that the value at $idx - 1$
was of type $Elem$ since $b.index$ was read.
This means that neither $hasElem(start, e)$ nor $sealedAt$ have changed after the CAS.
Since after the CAS there is a $Terminal$ with an additional function $f$ at $idx$,
the $hasCallback(start, f)$ holds after the CAS.
Finally, the $willBeCalled(start, e, f)$ holds for all elements $e$
for which the $hasElem(e)$ holds, since the CAS has been preceeded by
a call $f(e)$ in line \ref{call_callback} for each element. The lemma
\ref{lemma-end-of-life} ensures that for each element $f$ was called
for stays in the pool indefinitely (i.e. is not removed).

Trivially, the time $t_1$ from the statement of the lemma is such that $t_1 = t_0$.
\end{proof}


\begin{lemma}[Seal correctness]\label{lemma-seal}
Given a FlowPool in state $\mathbb{S}$ consistent with some abstract pool state $\mathbb{A}$, 
a successful CAS in line \ref{cas_callback} at some time $t_0$ changes the state of the FlowPool 
to $\mathbb{S}_0$ consistent with an abstract pool state $\mathbb{A}_0$, such that:

$\mathbb{A} = (elems, callbacks, seal)$, where $seal \in \{ \emptyset, \{ s \} \}$

$\mathbb{A}_0 = (elems, callbacks, \{ s \})$
\end{lemma}

\begin{proof}
Similar to the proof of lemma \ref{lemma-foreach}.
\end{proof}


\begin{definition}[Obstruction-freedom]
Given a FlowPool in a valid state, an operation $op$ is
\textbf{obstruction-free} if and only if a thread T executing the
operation $op$ completes within a finite number of steps given that
no other thread was executing the operation $op$ since T started executing it.

We say that thread T executes the operation $op$ \textbf{in isolation}.
\end{definition}


\begin{lemma}[Obstruction-free operations]\label{lemma-obstruction-free}
The FlowPool operations are obstruction-free.
\end{lemma}

\begin{proof}
By trivial sequential code analysis supported by the fact that the
invariants (especially [INV2]) hold in a valid state.
\end{proof}

\begin{proof}[Safety]
From lemmas \ref{lemma-housekeeping}, \ref{lemma-append}, \ref{lemma-foreach} and
\ref{lemma-seal} directly, along with the fact that all operations
executing in  isolation complete after a finite number of steps by lemma \ref{lemma-obstruction-free}.
\end{proof}


% You are strongly encouraged to use \LaTeXe{} for the
% preparation of your camera-ready manuscript together with the
% corresponding Springer class file \verb+llncs.cls+. Only if you use
% \LaTeXe{} can hyperlinks be generated in the online version
% of your manuscript.

% The \LaTeX{} source of this instruction file for \LaTeX{} users may be
% used as a template. This is
% located in the ``authors'' subdirectory in
% \url{ftp://ftp.springer.de/pub/tex/latex/llncs/latex2e/instruct/} and
% entitled \texttt{typeinst.tex}. There is a separate package for Word 
% users. Kindly send the final and checked source
% and PDF files of your paper to the Contact Volume Editor. This is
% usually one of the organizers of the conference. You should make sure
% that the \LaTeX{} and the PDF files are identical and correct and that
% only one version of your paper is sent. It is not possible to update
% files at a later stage. Please note that we do not need the printed
% paper.

% We would like to draw your attention to the fact that it is not possible
% to modify a paper in any way, once it has been published. This applies
% to both the printed book and the online version of the publication.
% Every detail, including the order of the names of the authors, should
% be checked before the paper is sent to the Volume Editors.

% \subsection{Checking the PDF File}

% Kindly assure that the Contact Volume Editor is given the name and email
% address of the contact author for your paper. The Contact Volume Editor
% uses these details to compile a list for our production department at
% SPS in India. Once the files have been worked upon, SPS sends a copy of
% the final pdf of each paper to its contact author. The contact author is
% asked to check through the final pdf to make sure that no errors have
% crept in during the transfer or preparation of the files. This should
% not be seen as an opportunity to update or copyedit the papers, which is
% not possible due to time constraints. Only errors introduced during the
% preparation of the files will be corrected.

% This round of checking takes place about two weeks after the files have
% been sent to the Editorial by the Contact Volume Editor, i.e., roughly
% seven weeks before the start of the conference for conference
% proceedings, or seven weeks before the volume leaves the printer's, for
% post-proceedings. If SPS does not receive a reply from a particular
% contact author, within the timeframe given, then it is presumed that the
% author has found no errors in the paper. The tight publication schedule
% of LNCS does not allow SPS to send reminders or search for alternative
% email addresses on the Internet.

% In some cases, it is the Contact Volume Editor that checks all the final
% pdfs. In such cases, the authors are not involved in the checking phase.

% \subsection{Additional Information Required by the Volume Editor}

% If you have more than one surname, please make sure that the Volume Editor
% knows how you are to be listed in the author index.

% \subsection{Copyright Forms}

% The copyright form may be downloaded from the ``For Authors"
% (Information for LNCS Authors) section of the LNCS Website:
% \texttt{www.springer.com/lncs}. Please send your signed copyright form
% to the Contact Volume Editor, either as a scanned pdf or by fax or by
% courier. One author may sign on behalf of all of the other authors of a
% particular paper. Digital signatures are acceptable.

% \section{Paper Preparation}

% Springer provides you with a complete integrated \LaTeX{} document class
% (\texttt{llncs.cls}) for multi-author books such as those in the LNCS
% series. Papers not complying with the LNCS style will be reformatted.
% This can lead to an increase in the overall number of pages. We would
% therefore urge you not to squash your paper.

% Please always cancel any superfluous definitions that are
% not actually used in your text. If you do not, these may conflict with
% the definitions of the macro package, causing changes in the structure
% of the text and leading to numerous mistakes in the proofs.

% If you wonder what \LaTeX{} is and where it can be obtained, see the
% ``\textit{LaTeX project site}'' (\url{http://www.latex-project.org})
% and especially the webpage ``\textit{How to get it}''
% (\url{http://www.latex-project.org/ftp.html}) respectively.

% When you use \LaTeX\ together with our document class file,
% \texttt{llncs.cls},
% your text is typeset automatically in Computer Modern Roman (CM) fonts.
% Please do
% \emph{not} change the preset fonts. If you have to use fonts other
% than the preset fonts, kindly submit these with your files.

% Please use the commands \verb+\label+ and \verb+\ref+ for
% cross-references and the commands \verb+\bibitem+ and \verb+\cite+ for
% references to the bibliography, to enable us to create hyperlinks at
% these places.

% For preparing your figures electronically and integrating them into
% your source file we recommend using the standard \LaTeX{} \verb+graphics+ or
% \verb+graphicx+ package. These provide the \verb+\includegraphics+ command.
% In general, please refrain from using the \verb+\special+ command.

% Remember to submit any further style files and
% fonts you have used together with your source files.

% \subsubsection{Headings.}

% Headings should be capitalized
% (i.e., nouns, verbs, and all other words
% except articles, prepositions, and conjunctions should be set with an
% initial capital) and should,
% with the exception of the title, be aligned to the left.
% Words joined by a hyphen are subject to a special rule. If the first
% word can stand alone, the second word should be capitalized.

% Here are some examples of headings: ``Criteria to Disprove
% Context-Freeness of Collage Language", ``On Correcting the Intrusion of
% Tracing Non-deterministic Programs by Software", ``A User-Friendly and
% Extendable Data Distribution System", ``Multi-flip Networks:
% Parallelizing GenSAT", ``Self-determinations of Man".

% \subsubsection{Lemmas, Propositions, and Theorems.}

% The numbers accorded to lemmas, propositions, and theorems, etc. should
% appear in consecutive order, starting with Lemma 1, and not, for
% example, with Lemma 11.

% \subsection{Figures}

% For \LaTeX\ users, we recommend using the \emph{graphics} or \emph{graphicx}
% package and the \verb+\includegraphics+ command.

% Please check that the lines in line drawings are not
% interrupted and are of a constant width. Grids and details within the
% figures must be clearly legible and may not be written one on top of
% the other. Line drawings should have a resolution of at least 800 dpi
% (preferably 1200 dpi). The lettering in figures should have a height of
% 2~mm (10-point type). Figures should be numbered and should have a
% caption which should always be positioned \emph{under} the figures, in
% contrast to the caption belonging to a table, which should always appear
% \emph{above} the table; this is simply achieved as matter of sequence in
% your source.

% Please center the figures or your tabular material by using the \verb+\centering+
% declaration. Short captions are centered by default between the margins
% and typeset in 9-point type (Fig.~\ref{fig:example} shows an example).
% The distance between text and figure is preset to be about 8~mm, the
% distance between figure and caption about 6~mm.

% To ensure that the reproduction of your illustrations is of a reasonable
% quality, we advise against the use of shading. The contrast should be as
% pronounced as possible.

% If screenshots are necessary, please make sure that you are happy with
% the print quality before you send the files.
% % \begin{figure}
% % \centering
% % \includegraphics[height=6.2cm]{eijkel2}
% % \caption{One kernel at $x_s$ (\emph{dotted kernel}) or two kernels at
% % $x_i$ and $x_j$ (\textit{left and right}) lead to the same summed estimate
% % at $x_s$. This shows a figure consisting of different types of
% % lines. Elements of the figure described in the caption should be set in
% % italics, in parentheses, as shown in this sample caption.}
% % \label{fig:example}
% % \end{figure}

% Please define figures (and tables) as floating objects. Please avoid
% using optional location parameters like ``\verb+[h]+" for ``here".

% \paragraph{Remark 1.}

% In the printed volumes, illustrations are generally black and white
% (halftones), and only in exceptional cases, and if the author is
% prepared to cover the extra cost for color reproduction, are colored
% pictures accepted. Colored pictures are welcome in the electronic
% version free of charge. If you send colored figures that are to be
% printed in black and white, please make sure that they really are
% legible in black and white. Some colors as well as the contrast of
% converted colors show up very poorly when printed in black and white.

% \subsection{Formulas}

% Displayed equations or formulas are centered and set on a separate
% line (with an extra line or halfline space above and below). Displayed
% expressions should be numbered for reference. The numbers should be
% consecutive within each section or within the contribution,
% with numbers enclosed in parentheses and set on the right margin --
% which is the default if you use the \emph{equation} environment, e.g.,
% \begin{equation}
%   \psi (u) = \int_{o}^{T} \left[\frac{1}{2}
%   \left(\Lambda_{o}^{-1} u,u\right) + N^{\ast} (-u)\right] dt \;  .
% \end{equation}

% Equations should be punctuated in the same way as ordinary
% text but with a small space before the end punctuation mark.

% \subsection{Footnotes}

% The superscript numeral used to refer to a footnote appears in the text
% either directly after the word to be discussed or -- in relation to a
% phrase or a sentence -- following the punctuation sign (comma,
% semicolon, or period). Footnotes should appear at the bottom of
% the
% normal text area, with a line of about 2~cm set
% immediately above them.\footnote{The footnote numeral is set flush left
% and the text follows with the usual word spacing.}

% \subsection{Program Code}

% Program listings or program commands in the text are normally set in
% typewriter font, e.g., CMTT10 or Courier.

% \medskip

% \noindent
% {\it Example of a Computer Program}
% \begin{verbatim}
% program Inflation (Output)
%   {Assuming annual inflation rates of 7%, 8%, and 10%,...
%    years};
%    const
%      MaxYears = 10;
%    var
%      Year: 0..MaxYears;
%      Factor1, Factor2, Factor3: Real;
%    begin
%      Year := 0;
%      Factor1 := 1.0; Factor2 := 1.0; Factor3 := 1.0;
%      WriteLn('Year  7% 8% 10%'); WriteLn;
%      repeat
%        Year := Year + 1;
%        Factor1 := Factor1 * 1.07;
%        Factor2 := Factor2 * 1.08;
%        Factor3 := Factor3 * 1.10;
%        WriteLn(Year:5,Factor1:7:3,Factor2:7:3,Factor3:7:3)
%      until Year = MaxYears
% end.
% \end{verbatim}
% %
% \noindent
% {\small (Example from Jensen K., Wirth N. (1991) Pascal user manual and
% report. Springer, New York)}

% \subsection{Citations}

% For citations in the text please use
% square brackets and consecutive numbers: \cite{jour}, \cite{lncschap},
% \cite{proceeding1} -- provided automatically
% by \LaTeX 's \verb|\cite| \dots\verb|\bibitem| mechanism.

% \subsection{Page Numbering and Running Heads}

% There is no need to include page numbers. If your paper title is too
% long to serve as a running head, it will be shortened. Your suggestion
% as to how to shorten it would be most welcome.

% \section{LNCS Online}

% The online version of the volume will be available in LNCS Online.
% Members of institutes subscribing to the Lecture Notes in Computer
% Science series have access to all the pdfs of all the online
% publications. Non-subscribers can only read as far as the abstracts. If
% they try to go beyond this point, they are automatically asked, whether
% they would like to order the pdf, and are given instructions as to how
% to do so.

% Please note that, if your email address is given in your paper,
% it will also be included in the meta data of the online version.

% \section{BibTeX Entries}

% The correct BibTeX entries for the Lecture Notes in Computer Science
% volumes can be found at the following Website shortly after the
% publication of the book:
% \url{http://www.informatik.uni-trier.de/~ley/db/journals/lncs.html}

% \subsubsection*{Acknowledgments.} The heading should be treated as a
% subsubsection heading and should not be assigned a number.

% \section{The References Section}\label{references}

% In order to permit cross referencing within LNCS-Online, and eventually
% between different publishers and their online databases, LNCS will,
% from now on, be standardizing the format of the references. This new
% feature will increase the visibility of publications and facilitate
% academic research considerably. Please base your references on the
% examples below. References that don't adhere to this style will be
% reformatted by Springer. You should therefore check your references
% thoroughly when you receive the final pdf of your paper.
% The reference section must be complete. You may not omit references.
% Instructions as to where to find a fuller version of the references are
% not permissible.

% We only accept references written using the latin alphabet. If the title
% of the book you are referring to is in Russian or Chinese, then please write
% (in Russian) or (in Chinese) at the end of the transcript or translation
% of the title.

% The following section shows a sample reference list with entries for
% journal articles \cite{jour}, an LNCS chapter \cite{lncschap}, a book
% \cite{book}, proceedings without editors \cite{proceeding1} and
% \cite{proceeding2}, as well as a URL \cite{url}.
% Please note that proceedings published in LNCS are not cited with their
% full titles, but with their acronyms!

% \begin{thebibliography}{4}

% \bibitem{jour} Smith, T.F., Waterman, M.S.: Identification of Common Molecular
% Subsequences. J. Mol. Biol. 147, 195--197 (1981)

% \bibitem{lncschap} May, P., Ehrlich, H.C., Steinke, T.: ZIB Structure Prediction Pipeline:
% Composing a Complex Biological Workflow through Web Services. In: Nagel,
% W.E., Walter, W.V., Lehner, W. (eds.) Euro-Par 2006. LNCS, vol. 4128,
% pp. 1148--1158. Springer, Heidelberg (2006)

% \bibitem{book} Foster, I., Kesselman, C.: The Grid: Blueprint for a New Computing
% Infrastructure. Morgan Kaufmann, San Francisco (1999)

% \bibitem{proceeding1} Czajkowski, K., Fitzgerald, S., Foster, I., Kesselman, C.: Grid
% Information Services for Distributed Resource Sharing. In: 10th IEEE
% International Symposium on High Performance Distributed Computing, pp.
% 181--184. IEEE Press, New York (2001)

% \bibitem{proceeding2} Foster, I., Kesselman, C., Nick, J., Tuecke, S.: The Physiology of the
% Grid: an Open Grid Services Architecture for Distributed Systems
% Integration. Technical report, Global Grid Forum (2002)

% \bibitem{url} National Center for Biotechnology Information, \url{http://www.ncbi.nlm.nih.gov}

% \end{thebibliography}


% \section*{Appendix: Springer-Author Discount}

% LNCS authors are entitled to a 33.3\% discount off all Springer
% publications. Before placing an order, the author should send an email, 
% giving full details of his or her Springer publication,
% to \url{orders-HD-individuals@springer.com} to obtain a so-called token. This token is a
% number, which must be entered when placing an order via the Internet, in
% order to obtain the discount.

% \section{Checklist of Items to be Sent to Volume Editors}
% Here is a checklist of everything the volume editor requires from you:


% \begin{itemize}
% \settowidth{\leftmargin}{{\Large$\square$}}\advance\leftmargin\labelsep
% \itemsep8pt\relax
% \renewcommand\labelitemi{{\lower1.5pt\hbox{\Large$\square$}}}

% \item The final \LaTeX{} source files
% \item A final PDF file
% \item A copyright form, signed by one author on behalf of all of the
% authors of the paper.
% \item A readme giving the name and email address of the
% corresponding author.
% \end{itemize}
\end{document}

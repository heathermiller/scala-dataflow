package scala.dataflow.array

import scala.dataflow.Future
import scala.annotation.tailrec
import scala.reflect.ClassTag

/**
 * A FlowArray that stores actual data
 * 
 * Any FlowArray that holds actual data (i.e. not a view) should
 * extend this class. This abstract base class holds common operations
 * for dependency tracking and blocking
 */
abstract class ConcreteFlowArray[A : ClassTag] extends FlowArray[A] with FAJob.Observer {

  import FlowArray._
  import SlicedJob._

  /**
   * dependency tracking information
   *
   * this holds the job which is responsible to calculate the values
   * of this ConcreteFlowArray. If null, the ConcreteFlowArray is
   * fully calculated.
   */
  @volatile
  private var srcJob: FAJob = null

  override def slice(start: Int, end: Int): FlowArray[A] =
    new FlowArraySliceView(this, start, end - start)

  override private[array] def transpose(from: Int, to: Int)(step: Int) = {
    val len = to - from + 1
    val ret = new FlatFlowArray(new Array[A](len))

    val tjob = dispatch(FATransposeJob(ret, step, from, len), 0, from, len)

    val ajob = FAAlignJob(tjob, 0, len)
    FAJob.schedule(ajob)

    ret.generatedBy(ajob)
    ret
  }

  /**
   * returns a job that re-aligns dependencies on this FlowArray with
   * a given offset and size
   */ 
  private[array] def align(offset: Int, size: Int) =
    FAAlignJob(this, offset, size - 1 + offset)

  /**
   * indicate that this ConcreteFlowArray is generated by another one
   *
   * Takes the generating job from another ConcreteFlowArray and set
   * it as generating job on this ConcreteFlowArray, too
   */
  private[array] final def generatedBy(fa: ConcreteFlowArray[_]) {
    val curJob = /*READ*/fa.srcJob
    if (curJob != null)
      generatedBy(curJob)
  }

  /**
   * indicate that this ConcreteFlowArray is generated by a given job
   *
   * Sets the job as generating job and adds this ConcreteFlowArray as
   * observer for correct completion tracking and blocking
   */
  private[array] final def generatedBy(job: FAJob) {
    srcJob = job
    job.addObserver(this)
  }

  override private[array] def sliceJobs(from: Int, to: Int): SliceDep = {
    for {  j <- Option(/*READ*/srcJob)
          js <- Some(j.destSliceJobs(from, to).filterNot(_.done)) if !js.isEmpty
        } yield (js, false)
  }

  /**
   * dispatch a job on a given range of this ConcreteFlowArray.
   *
   * This convenience method checks if the job needs to be dispatched
   * on the whole CFA. If so, it adds the job to the dependency queue
   * of the generating job. Otherwise it dispatches a job for
   * re-alignment with the given slice
   */
  private[array] final def dispatch(newJob: FAJob, srcOffset: Int, length: Int) {
    val curJob = /*READ*/srcJob

    if (curJob == null) {
      FAJob.schedule(newJob)
    } else if (srcOffset == 0 && length == size) {
      curJob.depending(newJob)
    } else {
      // We need to realign the thing... :(
      val raj = this.align(srcOffset, length)
      FAJob.schedule(raj)
      raj.depending(newJob)
    }
  }

  override private[array] final def tryAddObserver(obs: FAJob.Observer) = {
    val curJob = /*READ*/srcJob
    curJob != null && curJob.tryAddObserver(obs)
  }

  override def done = {
    val job = /*READ*/srcJob
    job == null || job.done
  }

  /** set this CFA as done (used by subclasses) */
  final protected def setDone() { srcJob = null }

}
